<!DOCTYPE html>

<!--Done in HTML and JS because it's easy to make a visual-->

<head>
    <style>
        .center{
            margin: auto;
            display: flex;
            align-items: center;
        }
        .border{
            border: 1px solid #555555;
        }
    </style>
</head>

<body style = "background-color: #000000;">
    <div class = "center">
        <canvas id = "canvas" class = "border" width = 600 height = 600 style = "margin: auto;"></canvas>
    </div>
</body>

<script>
    let canvas = document.getElementById("canvas");
    let context = canvas.getContext("2d");

    let viewportSize = 1;

    function Draw(x, y, color){
        x = canvas.width/2 + x;
        y = canvas.height/2 - y;
        color = "rgba("+color[0]+","+color[1]+","+color[2]+","+color[3]/255+")";
        context.fillStyle = color;
        context.fillRect(x,y,1,1);
    }

    // Screen Space
    function CanvasToViewport(x, y){
        return [
            x * viewportSize / canvas.width,
            y * viewportSize / canvas.height,
            viewportSize
        ];
    }

    function InRange(n, min, max){
        return ( n >= min && n <= max );
    }

    let red = [255, 50, 50, 255];
    let black = [0, 0, 0, 255];
    let grey = [150, 150, 150, 255];
    let blue = [50, 50, 255, 255];
    let green = [50, 255, 50 ,255];

    let purple = [87, 95, 207, 255];
    let orange = [255, 94, 87, 255];
    let mint = [11, 232, 129, 255]

    // Vector math
    function Dot(v1,v2){
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }
    function Minus(v1, v2){
        return [ v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2] ];
    }
    function Add(v1, v2){
        return [ v1[0] + v2[0], v1[1] + v2[1], v1[1] + v2[2] ];
    }
    function Magnitude(v1){
        return Math.sqrt(v1[0]**2 + v1[1]**2 + v1[2]**2);
    }
    // These parameters are all backwards and make no sense intuitively lol
    function MultConst(n, v1){
        return [ v1[0] * n, v1[1] * n, v1[2] * n ];
    }
    function AddConst(n, v1){
        return [ v1[0] + n, v1[1] + n, v1[2] + n ];
    }
    function DivConst(n, v1){
        return [ v1[0] / n, v1[1] / n, v1[2] / n ];
    }

    function ClampColor(c){
        return [
            Math.min(255, Math.max(0, c[0])),
            Math.min(255, Math.max(0, c[1])),
            Math.min(255, Math.max(0, c[2])),
            255,
        ];
    }

    // Object instance
    class ball {
        constructor(p, r, c){
            this.p = p;
            this.r = r;
            this.color = c;
        }
    }

    let AMBIENT = 1;
    let POINT = 2;
    let DIRECTIONAL = 3;
    class light {
        constructor(t, i, d){
            this.type = t;
            this.intensity = i;
            this.source = d; // either position or direction
        }
    }

    let instances = [
        new ball([0, -5, 20], 5, orange),
        new ball([-2, 2, 5], 2, purple),
        new ball([2, 2, 5], 1, mint),
        new ball([0,-5005,0], 5000, grey),
        new ball([0, 0, 50], 10, blue)
    ];

    let lights = [
        new light(AMBIENT, 0.2),
        new light(DIRECTIONAL, 0.2, [1, 4, 4]),
        new light(POINT, 0.6, [5,5,-5])
    ]

    function MakeLighting(position, normal){
        let i = 0;
        for (let li of lights){
            if (li.type == AMBIENT){
                i += li.intensity;
            } else {
                let direction = null;
                if (li.type == POINT) {
                    // position and direction are both stored in "source" lol
                    direction = Minus(li.source, position);
                } else {
                    direction = li.source;
                }

                let angle = Dot(normal, direction);
                if (angle > 0) {
                    i += li.intensity * angle / (Magnitude(normal) * Magnitude(direction));
                }
            }
        }
        return i = Math.max(0, Math.min(1, i));; // Clamp [0,1];
    }

    function GetIntersects(o, d, obj){
        let r = obj.r;
        let oc = Minus(o, obj.p);

        let a = Dot(d, d);
        let b = 2 * Dot(oc, d);
        let c = Dot(oc, oc) - (r*r);

        let di = (b*b) - (4*a*c);
        if (di < 0) {
            return [Infinity, Infinity];
        }

        let p1 = ( (-b + Math.sqrt(di)) / (2*a) );
        let p2 = ( (-b - Math.sqrt(di)) / (2*a) );
        return [p1, p2];
    }

    function Ray(o, d, dMin, dMax){
        let leastDistance = Infinity;
        let near = null;
        for (let obj of instances){
            let p = GetIntersects(o, d, obj);
            if (InRange(p[0], dMin, dMax) && p[0] < leastDistance){
                leastDistance = p[0];
                near = obj;
            } 
            if (InRange(p[1], dMin, dMax) && p[1] < leastDistance){
                leastDistance = p[1];
                near = obj;
            }
        }

        if (near == null){
            return black;
        }

        let newColor = near.color;
        // DIFFUSE

        // intersection = d * leastDistance + origin
        let intersect = MultConst(leastDistance, d);
        intersect = Add(intersect, o);

        let normal = Minus(intersect, near.p);
        let mag = Magnitude(normal);
        normal = MultConst(1/mag, normal);

        // let intersect = Add(o, MultConst(leastDistance, d)); // Find the point on the circle in 3d space ( CameraPosition + (LookVector * Distance) )
        // let normal = Minus(intersect, near.p); // Normal vector pointing from the inside of the circle to the intersection point. Not a unit vector tho
        // normal = DivConst(Magnitude(normal), normal); // NOW IT'S A UNIT VECTOR

        let harshness = MakeLighting(intersect, normal);
        newColor = MultConst(harshness, newColor);
        newColor[3] = 255;

        //newColor = near.color;
        return newColor;
    }

    function main(){
        let cameraPosition = [0, 0, 0];
        for (let x = -canvas.width/2; x < canvas.width/2; x++){
            for (let y = -canvas.height/2; y < canvas.height/2; y++){
                let direction = CanvasToViewport(x, y);
                let color = Ray(cameraPosition, direction, 1, Infinity);
                Draw(x, y, color);
            }
        }
    }
    main();

</script>